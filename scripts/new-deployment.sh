#!/bin/bash
# ABOUTME: Generate a .env file for a new deployment with unique ports and isolated Docker resources.
# ABOUTME: Enables running multiple luthien-proxy instances on the same machine without conflicts.

set -e
set -u

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

usage() {
    cat <<EOF
Create a new luthien-proxy deployment with unique ports.

Usage: $0 <deployment-name> [--offset N]

Arguments:
  deployment-name   Name for this deployment (used as COMPOSE_PROJECT_NAME prefix)

Options:
  --offset N        Port offset from defaults (default: auto-detect from existing .env files)
  --output FILE     Write to FILE instead of .env (useful for managing multiple .env files)
  --dry-run         Print the .env contents without writing
  -f, --force       Skip confirmation prompt (useful for CI/automation)
  -h, --help        Show this help

Examples:
  $0 experiment1                  # Auto-picks available port offset
  $0 experiment2 --offset 100     # Explicit offset: gateway=8100, postgres=5532, etc.
  $0 staging --output .env.staging

Port mapping with --offset 100:
  Gateway:    8000 -> 8100
  PostgreSQL: 5432 -> 5532
  Redis:      6379 -> 6479
  Tempo OTLP: 4317 -> 4417
  Tempo HTTP: 3200 -> 3300
  Loki:       3100 -> 3200
  Grafana:    3000 -> 3100

To use a non-default .env file:
  docker compose --env-file .env.staging up -d
EOF
}

# --- Parse arguments ---

DEPLOYMENT_NAME=""
PORT_OFFSET=""
OUTPUT_FILE=".env"
DRY_RUN=false
FORCE=false

while [[ $# -gt 0 ]]; do
    case "$1" in
        --offset)
            if [[ $# -lt 2 ]] || [[ "$2" == -* ]]; then
                echo "Error: --offset requires a numeric value"
                exit 1
            fi
            PORT_OFFSET="$2"
            shift 2
            ;;
        --output)
            if [[ $# -lt 2 ]] || [[ "$2" == -* ]]; then
                echo "Error: --output requires a filename"
                exit 1
            fi
            OUTPUT_FILE="$2"
            shift 2
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        -f|--force)
            FORCE=true
            shift
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        -*)
            echo "Error: unknown option '$1'"
            usage
            exit 1
            ;;
        *)
            if [[ -z "$DEPLOYMENT_NAME" ]]; then
                DEPLOYMENT_NAME="$1"
            else
                echo "Error: unexpected argument '$1'"
                usage
                exit 1
            fi
            shift
            ;;
    esac
done

if [[ -z "$DEPLOYMENT_NAME" ]]; then
    echo "Error: deployment name is required."
    echo
    usage
    exit 1
fi

# Sanitize deployment name for use as Docker project name
SANITIZED_NAME=$(echo "$DEPLOYMENT_NAME" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9_-]/-/g')

cd "$PROJECT_ROOT"

# --- Auto-detect port offset if not specified ---

if [[ -z "$PORT_OFFSET" ]]; then
    # Scan existing .env* files to find the highest offset in use
    max_gateway=8000
    for envfile in .env .env.*; do
        [[ -f "$envfile" ]] || continue
        gw_port=$(grep "^GATEWAY_PORT=" "$envfile" 2>/dev/null | sed 's/^[^=]*=//')
        if [[ -n "$gw_port" ]] && [[ "$gw_port" =~ ^[0-9]+$ ]] && [[ "$gw_port" -gt "$max_gateway" ]]; then
            max_gateway="$gw_port"
        fi
    done

    if [[ "$max_gateway" -eq 8000 ]]; then
        PORT_OFFSET=100
    else
        current_offset=$((max_gateway - 8000))
        PORT_OFFSET=$((current_offset + 100))
    fi

    echo "Auto-selected port offset: $PORT_OFFSET"
fi

# Validate offset is a number
if ! [[ "$PORT_OFFSET" =~ ^[0-9]+$ ]]; then
    echo "Error: port offset must be a positive integer, got '$PORT_OFFSET'"
    exit 1
fi

# --- Compute ports ---

GATEWAY_PORT=$((8000 + PORT_OFFSET))
POSTGRES_PORT=$((5432 + PORT_OFFSET))
REDIS_PORT=$((6379 + PORT_OFFSET))
TEMPO_OTLP_PORT=$((4317 + PORT_OFFSET))
TEMPO_HTTP_PORT=$((3200 + PORT_OFFSET))
LOKI_PORT=$((3100 + PORT_OFFSET))
GRAFANA_PORT=$((3000 + PORT_OFFSET))

# --- Source API keys from existing .env if available ---

OPENAI_API_KEY="your_openai_api_key_here"
ANTHROPIC_API_KEY="your_anthropic_api_key_here"

if [[ -f .env ]]; then
    existing_openai=$(grep "^OPENAI_API_KEY=" .env 2>/dev/null | sed 's/^[^=]*=//')
    existing_anthropic=$(grep "^ANTHROPIC_API_KEY=" .env 2>/dev/null | sed 's/^[^=]*=//')
    if [[ -n "$existing_openai" ]]; then
        OPENAI_API_KEY="$existing_openai"
    fi
    if [[ -n "$existing_anthropic" ]]; then
        ANTHROPIC_API_KEY="$existing_anthropic"
    fi
fi

# --- Generate .env content ---

ENV_CONTENT="# Luthien deployment: ${DEPLOYMENT_NAME}
# Generated by scripts/new-deployment.sh (port offset: ${PORT_OFFSET})

COMPOSE_PROJECT_NAME=luthien-${SANITIZED_NAME}

# LLM Provider API Keys
OPENAI_API_KEY=${OPENAI_API_KEY}
ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}

# Gateway Configuration
PROXY_API_KEY=sk-luthien-dev-key
ADMIN_API_KEY=admin-dev-key
GATEWAY_HOST=localhost
GATEWAY_PORT=${GATEWAY_PORT}

# Policy Configuration
POLICY_SOURCE=db-fallback-file
POLICY_CONFIG=/app/config/policy_config.yaml

# PostgreSQL Configuration
POSTGRES_USER=luthien
POSTGRES_PASSWORD=luthien_dev_password
POSTGRES_DB=luthien_control
POSTGRES_PORT=${POSTGRES_PORT}
DATABASE_URL=postgresql://luthien:luthien_dev_password@db:5432/luthien_control

# Redis Configuration
REDIS_URL=redis://redis:6379
REDIS_PORT=${REDIS_PORT}

# Test model
TEST_MODEL=gpt-4o-mini

# OpenTelemetry Configuration
OTEL_EXPORTER_OTLP_ENDPOINT=http://tempo:4317
OTEL_ENABLED=true
SERVICE_NAME=luthien-proxy
SERVICE_VERSION=2.0.0
ENVIRONMENT=development

# Observability Ports
TEMPO_OTLP_PORT=${TEMPO_OTLP_PORT}
TEMPO_HTTP_PORT=${TEMPO_HTTP_PORT}
LOKI_PORT=${LOKI_PORT}
GRAFANA_PORT=${GRAFANA_PORT}

# Grafana URL (adjusted for this deployment's port)
GRAFANA_URL=http://localhost:${GRAFANA_PORT}
"

# --- Output ---

if [[ "$DRY_RUN" == "true" ]]; then
    echo "$ENV_CONTENT"
    exit 0
fi

# Resolve output path relative to project root
if [[ "$OUTPUT_FILE" != /* ]]; then
    OUTPUT_FILE="${PROJECT_ROOT}/${OUTPUT_FILE}"
fi

if [[ -f "$OUTPUT_FILE" ]] && [[ "$FORCE" != "true" ]]; then
    echo "Warning: $OUTPUT_FILE already exists."
    read -p "Overwrite? (y/N) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Cancelled."
        exit 1
    fi
fi

echo "$ENV_CONTENT" > "$OUTPUT_FILE"
chmod 600 "$OUTPUT_FILE"

echo ""
echo "Created deployment '${DEPLOYMENT_NAME}' -> ${OUTPUT_FILE}"
echo ""
echo "Ports:"
echo "  Gateway:    ${GATEWAY_PORT}"
echo "  PostgreSQL: ${POSTGRES_PORT}"
echo "  Redis:      ${REDIS_PORT}"
echo "  Tempo OTLP: ${TEMPO_OTLP_PORT}  (observability profile)"
echo "  Tempo HTTP: ${TEMPO_HTTP_PORT}  (observability profile)"
echo "  Loki:       ${LOKI_PORT}  (observability profile)"
echo "  Grafana:    ${GRAFANA_PORT}  (observability profile)"
echo ""

if [[ "$OUTPUT_FILE" == "${PROJECT_ROOT}/.env" ]]; then
    echo "Start this deployment:"
    echo "  docker compose up -d"
else
    RELATIVE_OUTPUT="${OUTPUT_FILE#${PROJECT_ROOT}/}"
    echo "Start this deployment:"
    echo "  docker compose --env-file ${RELATIVE_OUTPUT} up -d"
fi
echo ""
echo "Stop this deployment:"
echo "  docker compose -p luthien-${SANITIZED_NAME} down"
